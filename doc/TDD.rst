======================
分布式服务器框架
======================

目标
----


公会、地图、战斗、玩家都是单独进程

1.系统必须能够应对超大量的并发活动。
2.必须在规定的时刻或规定的时间内完成任务。
软实时(soft real-time)——在电信系统中,很多操作必须要在规定 的时间内完成。其中有些操作是严格要求实时的,也就是说如果给定的 操作在给定的时段里没有执行完,整个操作就被取消。而有些操作只是 受到某种形式的定时器的监视,如果定时器超时而操作尚未完成,则重 新执行一遍。

  编写这样的系统,就需要有效地管理起数以万计的定时器。
6.系统要具有复杂的功能,例如:特性冲突。
7.系统应该能不间断运行许多年。
8.软件维护(例如重配置等)应该能在不停止系统的情况下进行。
即使在发生错误时,交换系 统也应该提供可接受的服务。特别是电话交换设备,可靠性要求极高1。
9.满足苛刻的质量和可靠性需求。
10.必须提供容错功能,包括硬件失灵和软件错误。
交换系统应该是“容错”的。即从开 始我们就知道会发生故障,但是我们必须设计出一些可以处理这些错误 的软件和硬件基础设施,并在发生故障的时候仍然能够提供可接受的服 务。

我们将软件组织成一个系统要完成的任务的层次结构,每一个任务对应 于一组目标,具有给定任务的软件必须尝试去完成和该任务相关的目 标。
所有任务按照复杂性排序。最顶层的任务最复杂。如果最顶层任务 完的目标都被完成,那么整个系统就运转正常。较低层次的任务应当能 够保持系统以一种可接受的方式运转,即使系统所提供的服务有所折 扣。
      系统中低层任务较高层任务更容易完成其目标。

首先,我们来进行一个分析,它有三个步骤: 1.从真实世界中的活动中识别出真正的并发活动; 2.识别出并发活动之间的所有消息通道; 3.写下能够在不同的消息通道中流通的所有消息
然后我们来编写程序。程序的结构要严格保持与问题的结构一致,即每一个 真实世界里的活动都严格映射到我们编程语言中的一个并发进程上。如果从问题 到程序的映射比例为 1:1,我们就说程序与问题是同构(isomorphic)的。

R1. 并发性——我们的系统必须支持并发性。创建或销毁一个并发进程的计
    算开销一定要非常小,即使创建大量的并发进程,也不应当带来灾难。
R2. 错误封装——一个进程中发生的错误一定不能破坏系统中其他的进程。
R3. 故障检测——一定要可以检测到本地异常(本地进程中发生的异常)和 远程异常(非本地进程中发生的异常)。
R4. 故障识别——我们要能够识别出异常产生的原因。
R5. 代码升级——要有某种机制来替换执行中的代码,而不必停下系统。
R6. 持久存储——我们需要把数据按某种策略存储下来,以便恢复一个已经 崩溃的系统。

他给出了他认为一个硬件系统如果要适合
在其上缔造可容错系统应该具备 3 条性质。Schneider 把这些性质称作: 1.故障即停(Halt on failure)——当一个处理器出错时,应当立即停止下
   来,而不是继续执行可能不正确的操作。
2.故障曝光性质(Failure status property)——当一个处理器发生故障时, 系统中的其他处理器应该得到通知,故障的原因必须交代清楚。
3.持久存储性质(Stable storage property)——处理器的存储器应当分为持 久存储器(stable storage,处理器崩掉时依然存在)和临时存储器(volatile storage,处理器崩掉就没了)。

Pid = spawn(F)
Pid ! Msg
register(Name, Pid)

1. 值错误(value error)——就是诸如“被 0 除”之类的错误。这种情况下 传给函数的参数的类型是正确的,但是值错了。
2. 类型错误(type error)——这类错误是指调用 Erlang 的内置函数的时候 所填的参数类型不正确。例如,有一个内置函数为 atom_to_list(A),是 将原子 A 转换成其 ASCII 码的一个整数列表。如果变量 A 并不是一个 原子,运行时系统就会产生一个异常。
3. 模式匹配错误(pattern-matching error)——这类错误是指试图将一个数 据结构与一些模式进行匹配,却找不到匹配成功的模式的错误。这种错 误会在函数头匹配时产生,或者在诸如 case,receive 或 if 语句中进行匹 配时产生。
4. 显式调用exi(t explicitexits)——这类错误是在显式调用表达式exit(Why) 时产生的,该调用会产生一个 Why 异常。
5. 错误传播(error propagation)——如果一个进程收到一个 exit 信号,它 可以选择停掉自己并把该 exit 信号传播给所有它连接着的进程(见 3.5.6 节)。
6. 系统异常(system exception)——运行时系统也许会因为内存耗尽或检测 到一个内部表不一致时终结掉一个进程。这类错误不在程序员的控制范 围之内。
Val = (catch Expr)
如果求值(catch Expr)返回了一个形如{‘EXIT’, W}的项式,那么我们就认 为表达式 Expr 因 W 而终止了。
可以通过调用 exit/1 原语来显式地生成一个异常。下面是一个例子:
       sqrt(X) when X < 0 ->
           exit({sqrt,X});
进程连接是将一组进程聚合在一起的一种方式,在进程连接中,任意一个进 程中发生了错误,其他所有的进程都将连带被停掉。
  进程监视者是用一个单独的进程来监视系统中的所有其他的进程。
  连接也可以在进程被创建的时候创建。如果 A 通过下面的调用方式来创建 进程 B:
        B = spawn_link(fun() -> ... end),

erlang:monitor/2 原语就是用来设置一个监视者的。如果进程 A 有求值:
        Ref = erlang:monitor(process, B)
那么当 B 因为原因 Why 死掉的时候,就会向 A 发送一条如下格式的消息: {’DOWN’, Ref, process, B, Why}
监视消息的发送者 A 和接收者 B 都不必是系统进程。

分布式处理需要如下两个原语:
spawn(Node,Fun)——在一个远端节点Node上产生一个处理函数是Fun 的进程。
monitor(Node)——用来监视整个节点的行为。


多语言支持

- 单一大服
- 无限的在线人数
- 每玩家每秒10次普通响应
- 每玩家每秒1次高压力响应
- 每玩家每秒1次玩家间互动
- 每玩家每秒1次社交团体间互动
- 无限的战斗副本
- 无限的AI数量
- 每秒一次重度AI
- 每秒5次轻度AI

设计思路
--------

参考erlang语言并发模型，基于消息机制。

整个框架包含以下几个层次，包含关系为Node->Process->FSM：

Node
====

一个Node对应一个操作系统进程，主要作用为从网络层接收消息并启动Process，包括以下几类：

Gate
	和Client直接连接，每个Client一个GateProcess接收消息，过滤，转发给对应的AppProcess服务器。

App
	运行应用逻辑的服务器，依然是每个Client对应一个Process，进行消息的处理。

Process
=======

一个Node包含多个Process，有以下几类：

Person
	直接对应一个Client，所有的合法消息先到这里来处理，然后再回复或者转发给其他Node。

Org
	对应一组Client，用于广播消息，处理组织类消息（例如公会、队伍、战斗）。

FSM
===

FSM是一颗自包含的树，一个Process中包含一颗FSM Tree分发、处理消息。这里已经涉及到具体的应用逻辑。

Message
=======

+ 所有的Message的传递、响应都是异步的。
+ Sender和Receiver都是Process。
+ Sender和Receiver可以在同一Node也可在不同Node。
+ Sender必须知道Receiver的ID才能发消息。
+ 消息的定义可以有Timeout，例如：

.. code:: go

	// Message
	type MLogin struct {
		ID	UID
	}

	type Timeout interface {
		time.Duration Interval()
	}

	// Timeout
	type TLogin Timeout

+ Sender可以选择是否处理Timeout
+ 消息发送流程如下：
	* Sender调用Notify接口：

	.. code:: go

		func Notify(sender UUID, receiver UUID, message interface{}, t Timeout)

	* 从Sender调用Notify的时刻起间隔timeout时间，Sender收到Timeout消息，流程结束

实现细节
--------

* 消息传递使用chan
* 
